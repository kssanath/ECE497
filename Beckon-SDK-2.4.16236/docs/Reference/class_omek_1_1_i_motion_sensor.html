<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Omek Beckon SDK: Omek::IMotionSensor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Omek Beckon SDK&#160;<span id="projectnumber">2.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>Omek</b>      </li>
      <li class="navelem"><a class="el" href="class_omek_1_1_i_motion_sensor.html">IMotionSensor</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Omek::IMotionSensor Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Omek::IMotionSensor" -->
<p>This class is the main interface for the Omek Beckon SDK.  
 <a href="class_omek_1_1_i_motion_sensor.html#details">More...</a></p>

<p><code>#include &lt;include/Shadow/IMotionSensor.h&gt;</code></p>

<p><a href="class_omek_1_1_i_motion_sensor-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_omek_1_1_i_sensor.html">ISensor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a21a2703c3b320791e72d27669935b744">getSensor</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a541ca9517db74159bd62551f811e2bbb">run</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the loop of grabbing, tracking, gesture detection etc. This method start a new thread, where all the processing is performed.  <a href="#a541ca9517db74159bd62551f811e2bbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#ad2e103a6ae85b8c68ecdec466c3022e8">stop</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the processing loop.  <a href="#ad2e103a6ae85b8c68ecdec466c3022e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a715f7e7551cffa85d995b5285e6969fb">pause</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a6d6ec6004e89df026537fe01098fcd2f">resume</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a952aabf39be05a03ca1500beb777d432">processNextImage</a> (bool waitForImage, bool &amp;hasNewImage)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully process the next image, using the existing grabber and managers This method works in two ways:  <a href="#a952aabf39be05a03ca1500beb777d432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#abf1d2ebab50618d0fef5e95601e2a14d">getNumOfGestures</a> (unsigned int &amp;numOfGestures, ListGestureMode isActivated) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#afc7fca56d0c38befd3c166db23fc32c5">getGestureName</a> (unsigned int gestureIndex, char *gestureName, unsigned int bufferSize, ListGestureMode isActived) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a34a345d6b2e080ceef600c01be21aac4">enableGesture</a> (const char *gestureName)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#abc8a50b14ee65d5d187d2c3813b01179">disableGesture</a> (const char *gestureName)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a3c611bd41d6f7aaf673e36058cabf7ae">disableAllGestures</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#ab6a74e2f24c703c0347180fdc4048f40">hasMoreGestures</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_omek_1_1_i_fired_event.html">IFiredEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#ad022e6c6a5c899961659b6fa555a747e">popNextGesture</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a5e09ba0a5b308cae64f5270b4e38697e">releaseGesture</a> (const <a class="el" href="class_omek_1_1_i_fired_event.html">IFiredEvent</a> *pGesture)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#af9fc2cbbeeb02bebfb92a76d4f7296c7">addGestureListener</a> (const char *gestureName, <a class="el" href="class_omek_1_1_i_gesture_listener.html">IGestureListener</a> *gestureListener)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an event listener for a gesture The gesture-listener should inherit from <a class="el" href="class_omek_1_1_i_gesture_listener.html" title="Interface for gesture events callbacks.">IGestureListener</a> The onGesture method will be called each time the gesture is recognized.  <a href="#af9fc2cbbeeb02bebfb92a76d4f7296c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a85dcf649a50c3f79647d529747f5592b">removeGestureListener</a> (const char *gestureName, <a class="el" href="class_omek_1_1_i_gesture_listener.html">IGestureListener</a> *gestureListener)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#aad5c4b2254d6335641fe39a69cc5e79d">enableAlert</a> (const AlertEventType &amp;alertEvent)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a055e1e0eb6741bae18bce0fa795540ec">disableAlert</a> (const AlertEventType &amp;alertEvent)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a815fe7c55a94be1bd4f447070718aec7">disableAllAlerts</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#ac36bbb5c3e6f5172667e8ab56f55b6a2">hasMoreAlerts</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_omek_1_1_i_fired_event.html">IFiredEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#ad9ceadb3ed4d68c4b81b45ed18f37e04">popNextAlert</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a7e2d09329cd2afac0f81eaa5459aa560">releaseAlert</a> (const <a class="el" href="class_omek_1_1_i_fired_event.html">IFiredEvent</a> *pAlert)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a21e134b1578237fc92d460e6d13ccded">getTrackingOptions</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#ac109846b250949998a79c930a36c501a">setTrackingOptions</a> (unsigned int trackingOptions)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#acf91acfa079ecb16af424400a2ac2f1c">setSmoothStrength</a> (unsigned int label, const JointID &amp;jointId, unsigned int smoothStrength)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#acfb6d2b8ff9399ff11e521f423aa8dab">getSmoothStrength</a> (unsigned int label, const JointID &amp;jointId) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a4b3913f3f9e46ad85023d5610ab07678">setMaxPlayers</a> (unsigned int nPlayers)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of players, to be tracked in the scene.  <a href="#a4b3913f3f9e46ad85023d5610ab07678"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a6a1c72c429b288bd93338b3d440394d3">getMaxPlayers</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#af4a03ca67ac1c7ca872d6c6765ef7eaf">setMaxCandidates</a> (unsigned int nBlobs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of blobs, to restricts the number of tracked blobs in the scene.  <a href="#af4a03ca67ac1c7ca872d6c6765ef7eaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a38d03828deef8ffa8dfb62a7d0871945">getMaxCandidates</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#aa25e610e0d4a83d75604be3306df951f">startTracking</a> (unsigned int label)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a0a79d7967c0c21f74124f783c9a1f2c2">stopTracking</a> (unsigned int label)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a34f0ab6b4b2334472d6368b97e883a3d">getSkeleton</a> (<a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a> *skeleton, unsigned int label=0) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a5acf0b47ccb253cd4f8afd727992877e">getRawSkeleton</a> (<a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a> *skeleton, unsigned int label=0) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a96c87ac11c98e7133273fd6912a9b5d5">getNumOfPlayers</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of active players.  <a href="#a96c87ac11c98e7133273fd6912a9b5d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#adf3b920c97423527d5cc23da1eb3d7b6">getFloorPlaneParams</a> (float point[3], float normal[3])=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the parameters defining the floor-plane in 3D Euclidean space in world-coordinates.  <a href="#adf3b920c97423527d5cc23da1eb3d7b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#ab9b0c32c62f2a8b179e766d3c6a3e940">setFloorPlaneKnownTrueParams</a> (float cameraHeightCm, float cameraLookdownAngleDegrees)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-initialize the floor plane object with known true floor plane parameter values, over-writing any previous estimation and re-initializing the internal state.  <a href="#ab9b0c32c62f2a8b179e766d3c6a3e940"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a44b87478c526799f72ed8b1e798c7a6d">isPlayerActive</a> (const unsigned int label) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a specific player is active.  <a href="#a44b87478c526799f72ed8b1e798c7a6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a8077a0d5ce9478e5e81c9cda67cd02da">copyRawImage</a> (char *copyImage, unsigned int bufferSize, int &amp;widthStep, bool bColor=true)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a7cd0562f95781873ab60b3235c9323a4">getRawImageSize</a> (unsigned int &amp;bufferSize, ImageType imageType)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a16adfe359461414256ed5dbb5e5a367d">copyPlayerMask</a> (char *copyMask, unsigned int bufferSize, unsigned int label, int &amp;width, int &amp;height, float center3D[3], float center2D[2]) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the 2D binary mask of the requested player.  <a href="#a16adfe359461414256ed5dbb5e5a367d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a1a9c396cef6972b64426bf83493c2db0">getNumOfCandidates</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a87b949e2e97837c8f101f1bbddf89286">copyCandidateMask</a> (char *copyMask, unsigned int bufferSize, unsigned int label, int &amp;width, int &amp;height, float center3D[3], float center2D[2]) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the 2D binary mask of a specific candidate.  <a href="#a87b949e2e97837c8f101f1bbddf89286"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#afa86ee257dcfb6fe7de068cb2191d0c0">resetBackground</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a1d851e381ccf356a5f6f50ba43ae1615">resetTracking</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a04a52f2f037126c034a27cd2abde1a17">restart</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a35b7724f50f0da21de657cf53fff20f5">hasNewFrameData</a> (void *id)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a11c0363f4142ebb814c53766fa75b8c4">recordSequence</a> (const char *filename, int nFrames)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Record a sequence directly from the camera.  <a href="#a11c0363f4142ebb814c53766fa75b8c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a91699aa6a4733d877090d8dfc66ac3c3">stopRecording</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop recording a sequence previously started with recordSequence.  <a href="#a91699aa6a4733d877090d8dfc66ac3c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#ad48ea4eb677ac64e05fb0eb2f27bec62">retargetMotion</a> (const char *characterName, const <a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a> *skeleton, const unsigned int label=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#af0ab619660a700af2c0b796f49e807ac">retargetMotion</a> (const char *characterName, const char *fbxCharacterFileNameFullPath, int &amp;usedNodesCount, char *usedBoneNames, int &amp;usedBonesBufferSize, const unsigned int label=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a344f0b5ce24d7f87c0a492b05eea29ac">removeTarget</a> (const char *characterName)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#ac48418ba4d9374dcec94bfb5cf5397b1">getRetargetedSkeleton</a> (<a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a> *skeleton, const char *characterName)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#aef79ad7748d97fc566c51f38861debba">getCharacterStateData</a> (void *allocatedArray, const char *characterName)=0</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_omek_1_1_i_motion_sensor.html">IMotionSensor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#ab60eb7626afcd27a379f0ba162998c84">createCameraSensor</a> (bool bExternalSensor=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="class_omek_1_1_i_motion_sensor.html" title="This class is the main interface for the Omek Beckon SDK.">IMotionSensor</a> with a live feed of a depth camera.  <a href="#ab60eb7626afcd27a379f0ba162998c84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a9f4d3f3a5beedc1651efb45ba05474d0">releaseMotionSensor</a> (<a class="el" href="class_omek_1_1_i_motion_sensor.html">IMotionSensor</a> *motionSensor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">release the motion sensor allocation  <a href="#a9f4d3f3a5beedc1651efb45ba05474d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_omek_1_1_i_motion_sensor.html">IMotionSensor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a55ebf7fcf8fbafba48bc8868b9be6f64">createSequenceSensor</a> (const char *sequence)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a500eba7b534a65eb59ef3a5adbe9b5f3">createSkeleton</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#a2ffa136b0f8e1b1020254b8a3af9c521">releaseSkeleton</a> (<a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a> *skeleton)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OMKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#aaf1f55f4ea2bf3074507716b908c866d">getLastError</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_omek_1_1_i_motion_sensor.html#adfde5dc4a22d771eb7e056997d70354f">setVerbosityLevel</a> (unsigned int level, const char *configFile=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set verbosity level of the SDK All output will be written according to the settings in the configuration file. See an example file installed in /bin. If the configFile is empty, the output will be written to stdout.  <a href="#adfde5dc4a22d771eb7e056997d70354f"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class is the main interface for the Omek Beckon SDK. </p>
<p>The Omek Beckon SDK provides a robust solution for real-time, 3D motion tracking using a depth camera. The thin and intuitive event-based C++ interface allows developers to quickly create immersive applications, and easily change existing user interfaces with 3D interaction. The middleware is fully compatible with any game engine, and natively supports the industry-standard FBX animation format for blending pre-generated content with real-time tracking. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af9fc2cbbeeb02bebfb92a76d4f7296c7"></a><!-- doxytag: member="Omek::IMotionSensor::addGestureListener" ref="af9fc2cbbeeb02bebfb92a76d4f7296c7" args="(const char *gestureName, IGestureListener *gestureListener)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::addGestureListener </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>gestureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_omek_1_1_i_gesture_listener.html">IGestureListener</a> *&#160;</td>
          <td class="paramname"><em>gestureListener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register an event listener for a gesture The gesture-listener should inherit from <a class="el" href="class_omek_1_1_i_gesture_listener.html" title="Interface for gesture events callbacks.">IGestureListener</a> The onGesture method will be called each time the gesture is recognized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gestureName</td><td>The name of the gesture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gestureListener</td><td>Pointer to the event listener </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_omek_1_1_i_gesture_listener.html#a3a7cfe1954741e3e005d765d12bc3c3d">IGestureListener::onGesture</a> </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the listener was successfully registered to the given gesture </dd></dl>

</div>
</div>
<a class="anchor" id="a87b949e2e97837c8f101f1bbddf89286"></a><!-- doxytag: member="Omek::IMotionSensor::copyCandidateMask" ref="a87b949e2e97837c8f101f1bbddf89286" args="(char *copyMask, unsigned int bufferSize, unsigned int label, int &amp;width, int &amp;height, float center3D[3], float center2D[2]) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::copyCandidateMask </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>copyMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>center3D</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>center2D</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a copy of the 2D binary mask of a specific candidate. </p>
<p>A candidate is a person detected in the scene which is not the main player. For example, when tracking one person and several people in the background, all those people will appear as candidate blobs. As soon as a person is tracked, his status changes from candidate to player, and his blob can then be accessed using copyPlayerMask instead. The size of the image is as the size of the depth image. when calling copyCandidateMask with size=0 the center of mass should be returned without copy of the mask.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copyMask</td><td>the buffer to copy to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>the size of the buffer, should be big enough </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_omek_1_1_i_motion_sensor.html#a7cd0562f95781873ab60b3235c9323a4">getRawImageSize</a> if bufferSize==0, we don't return copy the mask to copyMask. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>the serial number of the candidate, who's mask was requested </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">width</td><td>the width of the candidate's bounding rectangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>the height of the candidate's bounding rectangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">center3D</td><td>the player blob's 3D center of mass in world space (cm) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">center2D</td><td>the player blob's 2D center of mass in local image space (pixels)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if candidate is valid and copy was successful </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_omek_1_1_i_motion_sensor.html#a16adfe359461414256ed5dbb5e5a367d" title="Get a copy of the 2D binary mask of the requested player.">IMotionSensor::copyPlayerMask</a> </dd>
<dd>
IMotionSensor::getNumCandidates </dd></dl>

</div>
</div>
<a class="anchor" id="a16adfe359461414256ed5dbb5e5a367d"></a><!-- doxytag: member="Omek::IMotionSensor::copyPlayerMask" ref="a16adfe359461414256ed5dbb5e5a367d" args="(char *copyMask, unsigned int bufferSize, unsigned int label, int &amp;width, int &amp;height, float center3D[3], float center2D[2]) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::copyPlayerMask </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>copyMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>center3D</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>center2D</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a copy of the 2D binary mask of the requested player. </p>
<p>In the output mask each pixel occupied by the player is white (value of 255) and all other pixels are black (value of 0) when calling copyPlayerMask with size=0 the center of mass should be returned without copy of the mask.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copyMask</td><td>the buffer to copy to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>the size of the buffer, should be big enough </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_omek_1_1_i_motion_sensor.html#a7cd0562f95781873ab60b3235c9323a4">getRawImageSize</a> if bufferSize==0, we don't return copy the mask to copyMask. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>the ID of the player who's mask should be retrieved </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">width</td><td>the width of the player's bounding rectangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>the height of the player's bounding rectangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">center3D</td><td>the player blob's 3D center of mass in world space (cm) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">center2D</td><td>the player blob's 2D center of mass in local image space (pixels)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if a current image exists and could be copied </dd></dl>

</div>
</div>
<a class="anchor" id="a8077a0d5ce9478e5e81c9cda67cd02da"></a><!-- doxytag: member="Omek::IMotionSensor::copyRawImage" ref="a8077a0d5ce9478e5e81c9cda67cd02da" args="(char *copyImage, unsigned int bufferSize, int &amp;widthStep, bool bColor=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::copyRawImage </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>copyImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>widthStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bColor</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the given image with the last captured image</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copyImage</td><td>a preallocated image buffer of appropriate dimensions and channels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>the buffer size of the a preallocated image buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">widthStep</td><td>size of an aligned image row in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bColor</td><td>if true (default), this image will be either and IR or RGB image depending on the camera; if false, the image will contain the depth data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if a current image exists and could be copied </dd></dl>

</div>
</div>
<a class="anchor" id="ab60eb7626afcd27a379f0ba162998c84"></a><!-- doxytag: member="Omek::IMotionSensor::createCameraSensor" ref="ab60eb7626afcd27a379f0ba162998c84" args="(bool bExternalSensor=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_omek_1_1_i_motion_sensor.html">IMotionSensor</a>* Omek::IMotionSensor::createCameraSensor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bExternalSensor</em> = <code>false</code></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use <a class="el" href="class_omek_1_1_i_motion_sensor.html" title="This class is the main interface for the Omek Beckon SDK.">IMotionSensor</a> with a live feed of a depth camera. </p>
<p>Live camera mode is used for running the application with a connected depth camera. This method will automatically detect the camera that is currently connected.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In case there are more than one cameras connected, the first one will be chosen. </dd>
<dd>
In case no camera is detected the creation will fail.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bExternalSensor</td><td>flag indicating that the sensor was already activated by another process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the created Sensor, or NULL in case of failure </dd></dl>

</div>
</div>
<a class="anchor" id="a55ebf7fcf8fbafba48bc8868b9be6f64"></a><!-- doxytag: member="Omek::IMotionSensor::createSequenceSensor" ref="a55ebf7fcf8fbafba48bc8868b9be6f64" args="(const char *sequence)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_omek_1_1_i_motion_sensor.html">IMotionSensor</a>* Omek::IMotionSensor::createSequenceSensor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get an instance of an offline sequence sensor. Sequence mode is useful for development and debugging of applications. It allows the developer to run the application without a camera, based on an offline pre-recorded file sequence.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sequence</td><td>the directory in which the sequence resides (e.g. "C:\\data\\set1"); </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the created Sensor, or NULL in case of failure </dd></dl>

</div>
</div>
<a class="anchor" id="a500eba7b534a65eb59ef3a5adbe9b5f3"></a><!-- doxytag: member="Omek::IMotionSensor::createSkeleton" ref="a500eba7b534a65eb59ef3a5adbe9b5f3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a>* Omek::IMotionSensor::createSkeleton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>an interface to a new skeleton </dd></dl>

</div>
</div>
<a class="anchor" id="a055e1e0eb6741bae18bce0fa795540ec"></a><!-- doxytag: member="Omek::IMotionSensor::disableAlert" ref="a055e1e0eb6741bae18bce0fa795540ec" args="(const AlertEventType &amp;alertEvent)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::disableAlert </td>
          <td>(</td>
          <td class="paramtype">const AlertEventType &amp;&#160;</td>
          <td class="paramname"><em>alertEvent</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable the report of a specific alert </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alertEvent</td><td>contains data on the event: name, id </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if unregistering to the alert succeeded </dd></dl>

</div>
</div>
<a class="anchor" id="a815fe7c55a94be1bd4f447070718aec7"></a><!-- doxytag: member="Omek::IMotionSensor::disableAllAlerts" ref="a815fe7c55a94be1bd4f447070718aec7" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::disableAllAlerts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable report of all alerts</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if unregistering to all alerts succeeded </dd></dl>

</div>
</div>
<a class="anchor" id="a3c611bd41d6f7aaf673e36058cabf7ae"></a><!-- doxytag: member="Omek::IMotionSensor::disableAllGestures" ref="a3c611bd41d6f7aaf673e36058cabf7ae" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::disableAllGestures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable report of all gestures</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if unregistering all of the gestures succeeded </dd></dl>

</div>
</div>
<a class="anchor" id="abc8a50b14ee65d5d187d2c3813b01179"></a><!-- doxytag: member="Omek::IMotionSensor::disableGesture" ref="abc8a50b14ee65d5d187d2c3813b01179" args="(const char *gestureName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::disableGesture </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>gestureName</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable the report of specific gesture (unregister) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gestureName</td><td>the name of the gesture to disable </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if unregistering to the gesture succeeded </dd></dl>

</div>
</div>
<a class="anchor" id="aad5c4b2254d6335641fe39a69cc5e79d"></a><!-- doxytag: member="Omek::IMotionSensor::enableAlert" ref="aad5c4b2254d6335641fe39a69cc5e79d" args="(const AlertEventType &amp;alertEvent)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::enableAlert </td>
          <td>(</td>
          <td class="paramtype">const AlertEventType &amp;&#160;</td>
          <td class="paramname"><em>alertEvent</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable the report of a specific alert</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alertEvent</td><td>contains data on the event: name, id </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if registration to the alert succeeded </dd></dl>

</div>
</div>
<a class="anchor" id="a34a345d6b2e080ceef600c01be21aac4"></a><!-- doxytag: member="Omek::IMotionSensor::enableGesture" ref="a34a345d6b2e080ceef600c01be21aac4" args="(const char *gestureName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::enableGesture </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>gestureName</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable the report of specific gesture using hasMoreGestures/popNextGesture </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gestureName</td><td>the name of the gesture to enable </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if registration to the gesture succeeded </dd></dl>

</div>
</div>
<a class="anchor" id="aef79ad7748d97fc566c51f38861debba"></a><!-- doxytag: member="Omek::IMotionSensor::getCharacterStateData" ref="aef79ad7748d97fc566c51f38861debba" args="(void *allocatedArray, const char *characterName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::getCharacterStateData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocatedArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>characterName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill array with translation and rotation of the skeleton joints for the selected retargeted character</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allocatedArray</td><td>an array to be filled with translation rotation values per joint. This array is ordered in [tx, ty, tz, rx, ry, rz, rw, ...] format, where [tx, ty, tz] is the translation, and [rx ry rz rw] is the rotation represented as a quaternion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>of the retargeted character </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if a legal character name was entered </dd></dl>

</div>
</div>
<a class="anchor" id="adf3b920c97423527d5cc23da1eb3d7b6"></a><!-- doxytag: member="Omek::IMotionSensor::getFloorPlaneParams" ref="adf3b920c97423527d5cc23da1eb3d7b6" args="(float point[3], float normal[3])=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::getFloorPlaneParams </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>point</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>normal</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the parameters defining the floor-plane in 3D Euclidean space in world-coordinates. </p>
<p>The 3D floor-plane parameters are defined using a point within the plane, and a vector normal to the plane: n * ( v - v0 ) = 0, where v0 is a 3D point within (on) the plane, n is the 3D vector normal to the plane, v is any point within (on) the plane (infinitely many), and "*" is the dot-product (non-normalized inner-product).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">point</td><td>corresponds to v0 in the definition above. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">normal</td><td>corresponds to n in the definition above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if succeeded , or an error code othherwise. If the floor-plane not valid for (i.e., real and visible), then ignore the other outputs. </dd></dl>

</div>
</div>
<a class="anchor" id="afc7fca56d0c38befd3c166db23fc32c5"></a><!-- doxytag: member="Omek::IMotionSensor::getGestureName" ref="afc7fca56d0c38befd3c166db23fc32c5" args="(unsigned int gestureIndex, char *gestureName, unsigned int bufferSize, ListGestureMode isActived) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::getGestureName </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>gestureIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>gestureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListGestureMode&#160;</td>
          <td class="paramname"><em>isActived</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>get the gesture name in the wanted index. if isActivated == ACTIVATED: get the activated gesture name. When tracking is used, returns the gesture that was enabled, otherwise returns the gesture that was activated in the file if isActivated == NOT_ACTIVATED: get the gesture name </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gestureIndex</td><td>(input) the index of the wanted gesture </td></tr>
    <tr><td class="paramname">gestureName</td><td>(output) the gesture name in the wanted index </td></tr>
    <tr><td class="paramname">bufferSize</td><td>(input) size of allocated buffer for the gesture name </td></tr>
    <tr><td class="paramname">isActived</td><td>(input) does the wanted gesture is from the activated gestures list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS for success, an error if failed </dd></dl>

</div>
</div>
<a class="anchor" id="aaf1f55f4ea2bf3074507716b908c866d"></a><!-- doxytag: member="Omek::IMotionSensor::getLastError" ref="aaf1f55f4ea2bf3074507716b908c866d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OMKStatus Omek::IMotionSensor::getLastError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the latest error value for this session </dd></dl>

</div>
</div>
<a class="anchor" id="a38d03828deef8ffa8dfb62a7d0871945"></a><!-- doxytag: member="Omek::IMotionSensor::getMaxCandidates" ref="a38d03828deef8ffa8dfb62a7d0871945" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Omek::IMotionSensor::getMaxCandidates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the maximal number of blobs that can be tracked in the scene </dd></dl>

</div>
</div>
<a class="anchor" id="a6a1c72c429b288bd93338b3d440394d3"></a><!-- doxytag: member="Omek::IMotionSensor::getMaxPlayers" ref="a6a1c72c429b288bd93338b3d440394d3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Omek::IMotionSensor::getMaxPlayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the maximal number of players that can be tracked </dd></dl>

</div>
</div>
<a class="anchor" id="a1a9c396cef6972b64426bf83493c2db0"></a><!-- doxytag: member="Omek::IMotionSensor::getNumOfCandidates" ref="a1a9c396cef6972b64426bf83493c2db0" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Omek::IMotionSensor::getNumOfCandidates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Candidates are observers that are typically behind the active players in the game. This function is useful in determining the number of people in the scene.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of player candidates in the scene </dd></dl>

</div>
</div>
<a class="anchor" id="abf1d2ebab50618d0fef5e95601e2a14d"></a><!-- doxytag: member="Omek::IMotionSensor::getNumOfGestures" ref="abf1d2ebab50618d0fef5e95601e2a14d" args="(unsigned int &amp;numOfGestures, ListGestureMode isActivated) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::getNumOfGestures </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numOfGestures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListGestureMode&#160;</td>
          <td class="paramname"><em>isActivated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>get the number of activated gestures / all available gestures </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">isActivated</td><td>what is the wanted gestures type </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numOfGestures</td><td>the amount of gestures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96c87ac11c98e7133273fd6912a9b5d5"></a><!-- doxytag: member="Omek::IMotionSensor::getNumOfPlayers" ref="a96c87ac11c98e7133273fd6912a9b5d5" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Omek::IMotionSensor::getNumOfPlayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of active players. </p>
<p>This method returns the number of active players. The number of tracked players is not the necessarily equal to the number of player we are trying to track!</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of active players </dd></dl>

</div>
</div>
<a class="anchor" id="a7cd0562f95781873ab60b3235c9323a4"></a><!-- doxytag: member="Omek::IMotionSensor::getRawImageSize" ref="a7cd0562f95781873ab60b3235c9323a4" args="(unsigned int &amp;bufferSize, ImageType imageType)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::getRawImageSize </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageType&#160;</td>
          <td class="paramname"><em>imageType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the needed buffer size for getting the last captured image, in case of image mode = mask - get the size of the player's bounding rectangle </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferSize</td><td>the buffer size of the raw image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageType</td><td>the wanted imageType </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if a current image exists </dd></dl>

</div>
</div>
<a class="anchor" id="a5acf0b47ccb253cd4f8afd727992877e"></a><!-- doxytag: member="Omek::IMotionSensor::getRawSkeleton" ref="a5acf0b47ccb253cd4f8afd727992877e" args="(ISkeleton *skeleton, unsigned int label=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::getRawSkeleton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a> *&#160;</td>
          <td class="paramname"><em>skeleton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get raw skeleton (no smoothing, etc.) for a given player</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">skeleton</td><td>pointer to a preallocated Skeleton, will hold the retrieved player's skeleton </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>the label of the player, who's skeleton should be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if a legal skeleton was retrieved </dd></dl>

</div>
</div>
<a class="anchor" id="ac48418ba4d9374dcec94bfb5cf5397b1"></a><!-- doxytag: member="Omek::IMotionSensor::getRetargetedSkeleton" ref="ac48418ba4d9374dcec94bfb5cf5397b1" args="(ISkeleton *skeleton, const char *characterName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::getRetargetedSkeleton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a> *&#160;</td>
          <td class="paramname"><em>skeleton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>characterName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the given skeleton with the joints data for the retargeted skeleton.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">skeleton</td><td>a skeleton to fill the joints data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">characterName</td><td>the name of the retargeted character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if a legal skeleton was retrieved </dd></dl>

</div>
</div>
<a class="anchor" id="a21a2703c3b320791e72d27669935b744"></a><!-- doxytag: member="Omek::IMotionSensor::getSensor" ref="a21a2703c3b320791e72d27669935b744" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_omek_1_1_i_sensor.html">ISensor</a>* Omek::IMotionSensor::getSensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a handle of the interface - <a class="el" href="class_omek_1_1_i_sensor.html" title="The ISensor class serves as both an interface to a connected 3D depth sensor, as well as a virtual ca...">ISensor</a> </p>

</div>
</div>
<a class="anchor" id="a34f0ab6b4b2334472d6368b97e883a3d"></a><!-- doxytag: member="Omek::IMotionSensor::getSkeleton" ref="a34f0ab6b4b2334472d6368b97e883a3d" args="(ISkeleton *skeleton, unsigned int label=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::getSkeleton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a> *&#160;</td>
          <td class="paramname"><em>skeleton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the given skeleton object with the current full-body tracking data of a player</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">skeleton</td><td>pointer to an instantiated skeleton interface, which will be filled by the method </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>the ID of the player that should be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if a legal player was found and the skeleton successfully filled </dd></dl>

</div>
</div>
<a class="anchor" id="acfb6d2b8ff9399ff11e521f423aa8dab"></a><!-- doxytag: member="Omek::IMotionSensor::getSmoothStrength" ref="acfb6d2b8ff9399ff11e521f423aa8dab" args="(unsigned int label, const JointID &amp;jointId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Omek::IMotionSensor::getSmoothStrength </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const JointID &amp;&#160;</td>
          <td class="paramname"><em>jointId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the strength of smoothing for a specific joint</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>player index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jointId</td><td>id of joint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21e134b1578237fc92d460e6d13ccded"></a><!-- doxytag: member="Omek::IMotionSensor::getTrackingOptions" ref="a21e134b1578237fc92d460e6d13ccded" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Omek::IMotionSensor::getTrackingOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the tracker flags </dd></dl>

</div>
</div>
<a class="anchor" id="ac36bbb5c3e6f5172667e8ab56f55b6a2"></a><!-- doxytag: member="Omek::IMotionSensor::hasMoreAlerts" ref="ac36bbb5c3e6f5172667e8ab56f55b6a2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Omek::IMotionSensor::hasMoreAlerts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there are more alerts in the queue </dd></dl>

</div>
</div>
<a class="anchor" id="ab6a74e2f24c703c0347180fdc4048f40"></a><!-- doxytag: member="Omek::IMotionSensor::hasMoreGestures" ref="ab6a74e2f24c703c0347180fdc4048f40" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Omek::IMotionSensor::hasMoreGestures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there are more gesture in the queue </dd></dl>

</div>
</div>
<a class="anchor" id="a35b7724f50f0da21de657cf53fff20f5"></a><!-- doxytag: member="Omek::IMotionSensor::hasNewFrameData" ref="a35b7724f50f0da21de657cf53fff20f5" args="(void *id)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Omek::IMotionSensor::hasNewFrameData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method can be called by different clients at the same time, as long as every client uses a different id. Each client should use the same id for successive calls</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>a unique identification of the caller client, typically the actual pointer of the invoking object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether there is new information since the last call with the same id </dd></dl>

</div>
</div>
<a class="anchor" id="a44b87478c526799f72ed8b1e798c7a6d"></a><!-- doxytag: member="Omek::IMotionSensor::isPlayerActive" ref="a44b87478c526799f72ed8b1e798c7a6d" args="(const unsigned int label) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Omek::IMotionSensor::isPlayerActive </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a specific player is active. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>The id of the player we want to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true If player is active (i.e. being tracked) </dd></dl>

</div>
</div>
<a class="anchor" id="a715f7e7551cffa85d995b5285e6969fb"></a><!-- doxytag: member="Omek::IMotionSensor::pause" ref="a715f7e7551cffa85d995b5285e6969fb" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pause the processing loop</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the process was successfully paused </dd></dl>

</div>
</div>
<a class="anchor" id="ad9ceadb3ed4d68c4b81b45ed18f37e04"></a><!-- doxytag: member="Omek::IMotionSensor::popNextAlert" ref="ad9ceadb3ed4d68c4b81b45ed18f37e04" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_omek_1_1_i_fired_event.html">IFiredEvent</a>* Omek::IMotionSensor::popNextAlert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the next alert in the queue and call releaseAlert to release the memory of this alert</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_omek_1_1_i_motion_sensor.html#a7e2d09329cd2afac0f81eaa5459aa560">IMotionSensor::releaseAlert</a> </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next alert in the queue </dd></dl>

</div>
</div>
<a class="anchor" id="ad022e6c6a5c899961659b6fa555a747e"></a><!-- doxytag: member="Omek::IMotionSensor::popNextGesture" ref="ad022e6c6a5c899961659b6fa555a747e" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_omek_1_1_i_fired_event.html">IFiredEvent</a>* Omek::IMotionSensor::popNextGesture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the next gesture and call releaseGesture to release the memory of this gesture</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_omek_1_1_i_motion_sensor.html#a5e09ba0a5b308cae64f5270b4e38697e">IMotionSensor::releaseGesture</a> </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next gesture in the queue, or NULL in case of failure </dd></dl>

</div>
</div>
<a class="anchor" id="a952aabf39be05a03ca1500beb777d432"></a><!-- doxytag: member="Omek::IMotionSensor::processNextImage" ref="a952aabf39be05a03ca1500beb777d432" args="(bool waitForImage, bool &amp;hasNewImage)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::processNextImage </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>hasNewImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fully process the next image, using the existing grabber and managers This method works in two ways: </p>
<ul>
<li>If the "waitForImage" is turned on, the method will return only when a new image was processed</li>
<li>If the "waitForImage" is turned off, the method will return immediately (check the hasNewImage flag in this case) NOTE: You must not mix calls to "processNextImage" with calls to "run". <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">waitForImage</td><td>decides if the method will wait for a new image, or return immediately </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hasNewImage</td><td>(output) indicates if a new image was processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if a new image was fully processed, or an error if a problem occurred </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a11c0363f4142ebb814c53766fa75b8c4"></a><!-- doxytag: member="Omek::IMotionSensor::recordSequence" ref="a11c0363f4142ebb814c53766fa75b8c4" args="(const char *filename, int nFrames)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::recordSequence </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFrames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Record a sequence directly from the camera. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the output file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nFrames</td><td>number of frames to record </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the sequence was opened successfully, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a7e2d09329cd2afac0f81eaa5459aa560"></a><!-- doxytag: member="Omek::IMotionSensor::releaseAlert" ref="a7e2d09329cd2afac0f81eaa5459aa560" args="(const IFiredEvent *pAlert)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::releaseAlert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_omek_1_1_i_fired_event.html">IFiredEvent</a> *&#160;</td>
          <td class="paramname"><em>pAlert</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the memory allocated for this alert</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAlert</td><td>pointer to the alert event that should be released </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_omek_1_1_i_motion_sensor.html#ad9ceadb3ed4d68c4b81b45ed18f37e04">IMotionSensor::popNextAlert</a> </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the memory was correctly released </dd></dl>

</div>
</div>
<a class="anchor" id="a5e09ba0a5b308cae64f5270b4e38697e"></a><!-- doxytag: member="Omek::IMotionSensor::releaseGesture" ref="a5e09ba0a5b308cae64f5270b4e38697e" args="(const IFiredEvent *pGesture)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::releaseGesture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_omek_1_1_i_fired_event.html">IFiredEvent</a> *&#160;</td>
          <td class="paramname"><em>pGesture</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the memory allocated for the gesture</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pGesture</td><td>pointer to the gesture event that should be released </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_omek_1_1_i_motion_sensor.html#ad022e6c6a5c899961659b6fa555a747e">IMotionSensor::popNextGesture</a> </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the memory was correctly released </dd></dl>

</div>
</div>
<a class="anchor" id="a9f4d3f3a5beedc1651efb45ba05474d0"></a><!-- doxytag: member="Omek::IMotionSensor::releaseMotionSensor" ref="a9f4d3f3a5beedc1651efb45ba05474d0" args="(IMotionSensor *motionSensor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OMKStatus Omek::IMotionSensor::releaseMotionSensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_omek_1_1_i_motion_sensor.html">IMotionSensor</a> *&#160;</td>
          <td class="paramname"><em>motionSensor</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>release the motion sensor allocation </p>
<p>relaseMotionSensor destroys the sensor and releases allocated resources. This is the opposite function of createCameraSensor/createSequenceSensor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">motionSensor</td><td>pointer to the instance to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if succeeded </dd></dl>

</div>
</div>
<a class="anchor" id="a2ffa136b0f8e1b1020254b8a3af9c521"></a><!-- doxytag: member="Omek::IMotionSensor::releaseSkeleton" ref="a2ffa136b0f8e1b1020254b8a3af9c521" args="(ISkeleton *skeleton)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OMKStatus Omek::IMotionSensor::releaseSkeleton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a> *&#160;</td>
          <td class="paramname"><em>skeleton</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the memory of the skeleton </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">skeleton</td><td>the skeleton to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if succeeded </dd></dl>

</div>
</div>
<a class="anchor" id="a85dcf649a50c3f79647d529747f5592b"></a><!-- doxytag: member="Omek::IMotionSensor::removeGestureListener" ref="a85dcf649a50c3f79647d529747f5592b" args="(const char *gestureName, IGestureListener *gestureListener)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::removeGestureListener </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>gestureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_omek_1_1_i_gesture_listener.html">IGestureListener</a> *&#160;</td>
          <td class="paramname"><em>gestureListener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unregister an event listener for a gesture</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gestureName</td><td>the name of the gesture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gestureListener</td><td>the event listener to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the listener was successfully unregistered to the given gesture </dd></dl>

</div>
</div>
<a class="anchor" id="a344f0b5ce24d7f87c0a492b05eea29ac"></a><!-- doxytag: member="Omek::IMotionSensor::removeTarget" ref="a344f0b5ce24d7f87c0a492b05eea29ac" args="(const char *characterName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::removeTarget </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>characterName</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the target character with the given name</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">characterName</td><td>identifier of the character to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the target was successfully removed </dd></dl>

</div>
</div>
<a class="anchor" id="afa86ee257dcfb6fe7de068cb2191d0c0"></a><!-- doxytag: member="Omek::IMotionSensor::resetBackground" ref="afa86ee257dcfb6fe7de068cb2191d0c0" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::resetBackground </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the image background information for this session (the backround around the players and candidates) of this session</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if reset was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a1d851e381ccf356a5f6f50ba43ae1615"></a><!-- doxytag: member="Omek::IMotionSensor::resetTracking" ref="a1d851e381ccf356a5f6f50ba43ae1615" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::resetTracking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset all tracking information (players, etc) for this session</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if reset was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a04a52f2f037126c034a27cd2abde1a17"></a><!-- doxytag: member="Omek::IMotionSensor::restart" ref="a04a52f2f037126c034a27cd2abde1a17" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::restart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Restart the session (including starting sequence from first frame) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if restart was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a6d6ec6004e89df026537fe01098fcd2f"></a><!-- doxytag: member="Omek::IMotionSensor::resume" ref="a6d6ec6004e89df026537fe01098fcd2f" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resume the processing loop</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the process was successfully resumed </dd></dl>

</div>
</div>
<a class="anchor" id="af0ab619660a700af2c0b796f49e807ac"></a><!-- doxytag: member="Omek::IMotionSensor::retargetMotion" ref="af0ab619660a700af2c0b796f49e807ac" args="(const char *characterName, const char *fbxCharacterFileNameFullPath, int &amp;usedNodesCount, char *usedBoneNames, int &amp;usedBonesBufferSize, const unsigned int label=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::retargetMotion </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>characterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fbxCharacterFileNameFullPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>usedNodesCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>usedBoneNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>usedBonesBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new animated character target, reading the skeleton's info from an FBX file</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">characterName</td><td>identifier of the new character </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fbxCharacterFileNameFullPath</td><td>path to the FBX file containing the character definition </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">usedNodesCount</td><td>the number of the actually used joints </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">usedBoneNames</td><td>a string containing the names of the bones used in the retargetting, each separated by <br/>
 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">usedBonesBufferSize</td><td>size of usedBoneNames string buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>ID of the tracked player </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if a new target was successfully created and added </dd></dl>

</div>
</div>
<a class="anchor" id="ad48ea4eb677ac64e05fb0eb2f27bec62"></a><!-- doxytag: member="Omek::IMotionSensor::retargetMotion" ref="ad48ea4eb677ac64e05fb0eb2f27bec62" args="(const char *characterName, const ISkeleton *skeleton, const unsigned int label=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::retargetMotion </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>characterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_omek_1_1_i_skeleton.html">ISkeleton</a> *&#160;</td>
          <td class="paramname"><em>skeleton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new animated character target, using the info of the given skeleton</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">characterName</td><td>identifier of the new character </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skeleton</td><td>defining the new character, to be added as a target </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>ID of the tracked player </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if a new target was successfully created and added </dd></dl>

</div>
</div>
<a class="anchor" id="a541ca9517db74159bd62551f811e2bbb"></a><!-- doxytag: member="Omek::IMotionSensor::run" ref="a541ca9517db74159bd62551f811e2bbb" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start the loop of grabbing, tracking, gesture detection etc. This method start a new thread, where all the processing is performed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the new processing thread was initiated successfully </dd></dl>

</div>
</div>
<a class="anchor" id="ab9b0c32c62f2a8b179e766d3c6a3e940"></a><!-- doxytag: member="Omek::IMotionSensor::setFloorPlaneKnownTrueParams" ref="ab9b0c32c62f2a8b179e766d3c6a3e940" args="(float cameraHeightCm, float cameraLookdownAngleDegrees)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::setFloorPlaneKnownTrueParams </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cameraHeightCm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cameraLookdownAngleDegrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-initialize the floor plane object with known true floor plane parameter values, over-writing any previous estimation and re-initializing the internal state. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Call this function only after checking that <a class="el" href="class_omek_1_1_i_sensor.html#aa104ede3bbe363b09717d40083aa459f" title="In sequence mode this will return false when reached the end of the sequence/or when there are no mor...">ISensor::isAlive()</a> is true </dd>
<dd>
Calling this function will prevent any future estimation of floor plane parameters. Therefore, call it only if you are certain of the high accuracy of the input arguments. </dd>
<dd>
Following a call to this function, the human user must let the floor be fully visible to the camera (un-occluded) for a few seconds, exactly as during start-up of the application.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cameraHeightCm</td><td>the perpendicular height of the camera from the floor plane &gt; 0, in cm. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cameraLookdownAngleDegrees</td><td>the camera's look-down inclination angle &gt; 0, in degrees, where 0 deg corresponds to no look-down. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if succeeded , or an error code othherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af4a03ca67ac1c7ca872d6c6765ef7eaf"></a><!-- doxytag: member="Omek::IMotionSensor::setMaxCandidates" ref="af4a03ca67ac1c7ca872d6c6765ef7eaf" args="(unsigned int nBlobs)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::setMaxCandidates </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nBlobs</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the maximum number of blobs, to restricts the number of tracked blobs in the scene. </p>
<p>Note that the number of tracked blobs highly depends on the field of view of the camera. In general, tracking more blobs works better as the field of view of the camera is wider. The upper limit of supported players is 5.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nBlobs</td><td>the new number of blobs to restricts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMKStatus if the maximal number of blobs was successfully set </dd></dl>

</div>
</div>
<a class="anchor" id="a4b3913f3f9e46ad85023d5610ab07678"></a><!-- doxytag: member="Omek::IMotionSensor::setMaxPlayers" ref="a4b3913f3f9e46ad85023d5610ab07678" args="(unsigned int nPlayers)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::setMaxPlayers </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nPlayers</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the maximum number of players, to be tracked in the scene. </p>
<p>Note that the number of tracked players highly depends on the field of view of the camera. In general, tracking more players works better as the field of view of the camera is wider. The upper limit of supported players is 5.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPlayers</td><td>the new number of players to be tracked </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the maximal number of tracked players was successfully set </dd></dl>

</div>
</div>
<a class="anchor" id="acf91acfa079ecb16af424400a2ac2f1c"></a><!-- doxytag: member="Omek::IMotionSensor::setSmoothStrength" ref="acf91acfa079ecb16af424400a2ac2f1c" args="(unsigned int label, const JointID &amp;jointId, unsigned int smoothStrength)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::setSmoothStrength </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const JointID &amp;&#160;</td>
          <td class="paramname"><em>jointId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>smoothStrength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the strength of smoothing for a specific joint</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>player index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jointId</td><td>id of joint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smoothStrength</td><td>smooth value (0 means no smooth --&gt; higher values means stronger smoothing) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac109846b250949998a79c930a36c501a"></a><!-- doxytag: member="Omek::IMotionSensor::setTrackingOptions" ref="ac109846b250949998a79c930a36c501a" args="(unsigned int trackingOptions)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::setTrackingOptions </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>trackingOptions</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set tracking options on the fly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trackingOptions</td><td>the flags of the tracking to be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ShadowDefines.h </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the new flags were successfully set </dd></dl>

</div>
</div>
<a class="anchor" id="adfde5dc4a22d771eb7e056997d70354f"></a><!-- doxytag: member="Omek::IMotionSensor::setVerbosityLevel" ref="adfde5dc4a22d771eb7e056997d70354f" args="(unsigned int level, const char *configFile=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Omek::IMotionSensor::setVerbosityLevel </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>configFile</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set verbosity level of the SDK All output will be written according to the settings in the configuration file. See an example file installed in /bin. If the configFile is empty, the output will be written to stdout. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>0 = none, 1 = critical, 2 = errors, 3 = warnings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configFile</td><td>optional name of log4cxx configuration file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa25e610e0d4a83d75604be3306df951f"></a><!-- doxytag: member="Omek::IMotionSensor::startTracking" ref="aa25e610e0d4a83d75604be3306df951f" args="(unsigned int label)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::startTracking </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start tracking a specific blob of interest. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>the index of blob to be track </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2e103a6ae85b8c68ecdec466c3022e8"></a><!-- doxytag: member="Omek::IMotionSensor::stop" ref="ad2e103a6ae85b8c68ecdec466c3022e8" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop the processing loop. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the process was closed successfully </dd></dl>

</div>
</div>
<a class="anchor" id="a91699aa6a4733d877090d8dfc66ac3c3"></a><!-- doxytag: member="Omek::IMotionSensor::stopRecording" ref="a91699aa6a4733d877090d8dfc66ac3c3" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::stopRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop recording a sequence previously started with recordSequence. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>OMK_SUCCESS if the sequence was opened successfully, false otherwise </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_omek_1_1_i_motion_sensor.html#a11c0363f4142ebb814c53766fa75b8c4" title="Record a sequence directly from the camera.">IMotionSensor::recordSequence</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0a79d7967c0c21f74124f783c9a1f2c2"></a><!-- doxytag: member="Omek::IMotionSensor::stopTracking" ref="a0a79d7967c0c21f74124f783c9a1f2c2" args="(unsigned int label)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OMKStatus Omek::IMotionSensor::stopTracking </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop tracking a specific player of interest. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>the index of player to be untracked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
 <img align=right  src="Icon.png">
